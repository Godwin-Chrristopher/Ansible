---
# New: Block to handle tasks for a single incident, with rescue for host-specific errors
- block:
    - name: Set  messages
      set_fact:
        message: |
          Investigating the High Memory ALert on server {{ current_incident_item.hostname }}.mcjunkinredman.com
          
    - name: Update ServiceNow incident {{ current_incident_item.incident_number }} (in-Progress)
      uri:
        url: "https://mrcglobaltest.service-now.com/api/now/table/incident/{{ current_incident_item.sys_id }}"
        method: PATCH
        user: "{{ servicenow_user }}"
        password: "{{ servicenow_password }}"
        force_basic_auth: yes
        body_format: json
        headers:
          Content-Type: "application/json"
        body: >-
          {% set body_data = {} %}
          {% set _ = body_data.update({
                      'state': '2',
                      'assigned_to': 'ansible_awx',
                      'comments': message | default('Investigating the High Memory ALert on server.')
                    }) %}
          {{ body_data | to_json }}
      register: servicenow_update_result
      failed_when: servicenow_update_result.status not in [200, 201, 202, 204]
    
    # Initialize the list to store Memory values from each poll
    - name: Initialize Memory_values_per_poll list
      set_fact:
        Memory_values_per_poll: []
      delegate_to: localhost # Ensure this runs on the controller
      run_once: true # Ensure it's initialized only once per incident process

    - name: Perform Memory polling and update ServiceNow on each poll
      include_tasks: perform_single_Memory_poll.yml # Call the new task file
      loop: "{{ range(1, poll_count | int + 1) | list }}"
      loop_control:
        loop_var: current_poll_iteration # Pass this for the poll-specific message
        pause: "{{ poll_interval }}" # Delay between each iteration (each poll and update)

    - name: Calculate average and max Memory from all polls
      set_fact:
        # Memory_values is now directly the list from `Memory_values_per_poll`
        Memory_values: "{{ Memory_values_per_poll }}"
        Memory_avg: "{{ (Memory_values_per_poll | sum / Memory_values_per_poll | length) | round(2) }}"
        Memory_max: "{{ Memory_values_per_poll | max }}"
      when: Memory_values_per_poll is defined and Memory_values_per_poll | length > 0

    - name: Analyze Memory usage (based on all polls)
      set_fact:
        Memory_ok: "{{ Memory_values | default([]) | select('lt', Memory_threshold) | list | length == poll_count }}"
      when: Memory_values is defined

    - name: get Memory top processes
      shell: |
                # Get top 11 processes by memory, including the header line
                PS_OUTPUT=$(ps aux --sort -%mem | head -n 11)
            
                # Use awk to parse the PS_OUTPUT and generate an HTML table rows
                TOP_PROCESS_HTML_ROWS=$(echo "$PS_OUTPUT" | awk '
                BEGIN {
                    # Optional: any setup you need at the beginning of the script
                }
            
                # Print data rows only (skipping the header)
                NR > 1 {
                    pid = $2
                    cpu_usage = $3
                    memory_kb = $6
                    process_name = $11
            
                    # Calculate memory in MB and remove path from process name
                    memory_mb = memory_kb / 1024
                    sub(".*/", "", process_name)
            
                    # Print the HTML table row
                    printf "<tr><td>%s</td><td>%s</td><td>%.2f</td><td>%.2f</td></tr>\n", pid, process_name, cpu_usage, memory_mb
                }
            
                END {
                    # Optional: any cleanup you need at the end
                }')
            
                # Output the complete HTML document
                echo "<html><head><style>"
                echo "body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #f4f4f4; }"
                echo ".container { max-width: 700px; margin: 30px auto; padding: 25px; background: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }"
                echo "h2 { color: #2c3e50; }"
                echo "p { font-size: 16px; }"
                echo "table { width: 100%; border-collapse: collapse; margin-top: 20px; }"
                echo "th, td { border: 1px solid #ddd; padding: 12px; }"
                echo "th { background-color: #3498db; color: white; }"
                echo "tr:nth-child(even) { background-color: #f9f9f9; }"
                echo "tr:hover { background-color: #f1f1f1; }"
                echo "</style></head><body>"
                echo "<div class=\"container\">"
                echo "<h2>Top 10 Processes by Memory Usage</h2>"
                echo "<p>This report displays the processes consuming the most memory on the system.</p>"
                echo "<table>"
                echo "<thead><tr>"
                echo "<th>PID</th>"
                echo "<th>Process Name</th>"
                echo "<th>CPU %</th>"
                echo "<th>Memory (MB)</th>"
                echo "</tr></thead><tbody>"
                echo "$TOP_PROCESS_HTML_ROWS"
                echo "</tbody></table>"
                echo "</div></body></html>"

      register: Memory_top
      delegate_to: "{{ current_incident_item.hostname }}.mcjunkinredman.com"
      # New: This task is allowed to fail, and the rescue block will catch it.
      ignore_errors: true

    # NEW TASK: Log incident details to CSV
    - name: Ensure CSV log file exists
      ansible.builtin.file:
        path: "/data/INC_CSV/Linux_memory_incidents.csv"
        state: touch
        mode: '0644'
      delegate_to: aztlrh9ansawx00.mcjunkinredman.com
      run_once: true # Ensure this only runs once per playbook, not per loop item

    # MODIFIED: Log incident details using shell to always append
    - name: Log incident details for upscaling analysis
      ansible.builtin.shell: |
        echo "{{ current_incident_item.hostname }},{{ current_incident_item.incident_number }},{{ ansible_date_time.iso8601 }}" >> "/data/INC_CSV/Linux_memory_incidents.csv"
      delegate_to: aztlrh9ansawx00.mcjunkinredman.com
      when: not ansible_check_mode

    # NEW TASK: Read and analyze CSV for recurring alerts (Upscaling suggestion)
    - name: Check for recurring alerts for {{ current_incident_item.hostname }}
      slurp:
        src: "/data/INC_CSV/Linux_memory_incidents.csv"
      register: Memory_incident_log
      delegate_to: aztlrh9ansawx00.mcjunkinredman.com
      when: not ansible_check_mode

    - name: Process CSV data - Decode and Split Lines
      set_fact:
        # This will create a list where each element is a line from the CSV
        decoded_csv_lines: "{{ Memory_incident_log.content | b64decode | split('\n') }}"
      when: Memory_incident_log.content is defined and not ansible_check_mode

    - name: Process CSV data - Filter for Server Alerts
      set_fact:
        # This will filter the lines to only include those matching the current hostname
        server_alerts: "{{ decoded_csv_lines | select('match', '^' + current_incident_item.hostname + ',') | list }}"
      # Only run if decoded_csv_lines was successfully set in the previous step
      when: decoded_csv_lines is defined and not ansible_check_mode

    - name: Process CSV data - Calculate Alert Count
      set_fact:
        # This calculates the length of the filtered list
        #alert_count: "1"
        alert_count: "{{ server_alerts | length }}"
      # Only run if server_alerts was successfully set in the previous step
      when: server_alerts is defined and not ansible_check_mode

    # - name: Suggest upscaling if alert count exceeds threshold
    #   block:
    #     - name: Send email for upscaling suggestion
    #       ansible.builtin.mail:
    #         host: mail1.mcjunkinredman.com
    #         from: Godwin.Monickaraj@mrcglobal.com
    #         to: Vinodkumar.Jeerangi@mrcglobal.com, Godwin.Monickaraj@mrcglobal.com
    #         subject: "Action Required: High Memory Alerts - Server Upscaling Suggestion for {{ current_incident_item.hostname }}"
    #         body: |
    #           Dear Team,

    #           This is an automated alert from Ansible AWX.
    #           We have observed {{ alert_count }} high Memory incidents for the server '{{ current_incident_item.hostname }}' over a period of time.
    #           The current incident ID is {{ current_incident_item.incident_number }}.

    #           This recurring pattern suggests that the server may be undersized for its workload.
    #           We recommend reviewing the server's resource utilization and considering an upgrade (e.g., adding more Memory cores or increasing clock speed).

    #           Please investigate further to prevent future performance degradation and incidents.

    #           Best Regards,
    #           Ansible Automation
    #       delegate_to: localhost
    #       when: alert_count | int >= 3 # Threshold for upscaling suggestion (e.g., 3 or more incidents)

      #   - name: Add work note to ServiceNow incident for upscaling suggestion
      #     uri:
      #       url: "https://mrcglobaltest.service-now.com/api/now/table/incident/{{ current_incident_item.sys_id }}"
      #       method: PATCH
      #       user: "{{ servicenow_user }}"
      #       password: "{{ servicenow_password }}"
      #       force_basic_auth: yes
      #       body_format: json
      #       headers:
      #         Content-Type: "application/json"
      #       body:
      #         work_notes: |
      #           Automated suggestion: This server ({{ current_incident_item.hostname }}) has triggered high Memory alerts {{ alert_count }} times.
      #           Consider reviewing its specifications for a potential upgrade to prevent recurring incidents.
      #     register: servicenow_upscale_worknote_result
      #     failed_when: servicenow_upscale_worknote_result.status not in [200, 201, 202, 204]
      #     when: alert_count | int >= 3 # Threshold for upscaling suggestion (e.g., 3 or more incidents)
      # when: alert_count is defined and alert_count | int >= 3 # Only run this block if upscaling is suggested
    - name: Set resolution/comment messages
      set_fact:
        resolution_message: |
          Automated resolution: Memory normalized for {{ current_incident_item.hostname }}.
          Average Memory over {{ poll_count }} polls: {{ Memory_avg | default('N/A') }}%.
          Max Memory during polls: {{ Memory_max | default('N/A') }}%.
          [code]
          {{ Memory_top.stdout | default('Failed to retrieve top processes.') }}
          [/code]
        comment_message: |
          Memory still high on {{ current_incident_item.hostname }}, investigation needed.
          Average Memory over {{ poll_count }} polls: {{ Memory_avg | default('N/A') }}%.
          Max Memory during polls: {{ Memory_max | default('N/A') }}%.
          Moving the Incident to new state again.

          [code]
          {{ Memory_top.stdout | default('Failed to retrieve top processes.') }}
          [/code]
      # Only run this if Memory_ok is defined (from analyze Memory usage) or Memory_top is registered
      when: Memory_ok is defined or (Memory_top is defined and Memory_top.stdout is defined) and alert_count is defined and alert_count | int < 3 

    - name: Set resolution/comment messages
      set_fact:
        comment_message: |
          Memory normalized, but recurring high Memory alerts detected. Investigation needed for potential upscaling.
          Average Memory over {{ poll_count }} polls: {{ Memory_avg | default('N/A') }}%.
          Max Memory during polls: {{ Memory_max | default('N/A') }}%.
          Moving the Incident to new state again.

          [code]
          {{ Memory_top.stdout | default('Failed to retrieve top processes.') }}
          [/code]
      # Only run this if Memory_ok is defined (from analyze Memory usage) or Memory_top is registered
      when: Memory_ok is defined or (Memory_top is defined and Memory_top.stdout is defined) and alert_count is defined and alert_count | int <=3

    - name: Update ServiceNow incident {{ current_incident_item.incident_number }} (Success Path)
      uri:
        url: "https://mrcglobaltest.service-now.com/api/now/table/incident/{{ current_incident_item.sys_id }}"
        method: PATCH
        user: "{{ servicenow_user }}"
        password: "{{ servicenow_password }}"
        force_basic_auth: yes
        body_format: json
        headers:
          Content-Type: "application/json"
        body: >-
          {% set body_data = {} %}
          {% if Memory_ok | default(false) and (alert_count is not defined or alert_count | int < 3) %}
            {% set _ = body_data.update({
                        'state': '6',
                        'assigned_to': 'ansible_awx',
                        'u_caused_by_a_change': 'no',
                        'close_code': 'Solved (Permanently)',
                        'close_notes': resolution_message | default('Automated resolution: Memory normalized.'),
                        'work_notes': resolution_message | default('Automated resolution: Memory normalized.')
                      }) %}
          {% elif alert_count is defined and alert_count | int >= 3 %}
            {% set _ = body_data.update({
                        'state': '9', 
                        'assigned_to': '',
                        'comments': comment_message | default('Memory normalized, but recurring high Memory alerts detected. Investigation needed for potential upscaling.'),
                        'work_notes': comment_message | default('Memory normalized, but recurring high Memory alerts detected. Investigation needed for potential upscaling.')
                      }) %}
          {% else %}
            {% set _ = body_data.update({
                        'state': '9',
                        'assigned_to': '',
                        'comments': comment_message | default('Memory still high, investigation needed.')
                      }) %}
          {% endif %}
          {{ body_data | to_json }}
      register: servicenow_update_result
      failed_when: servicenow_update_result.status not in [200, 201, 202, 204]

  # New: Rescue block for host-specific errors (network, shell failures)
  rescue:
    - name: Update ServiceNow incident {{ current_incident_item.incident_number }} (Error Path)
      uri:
        url: "https://mrcglobaltest.service-now.com/api/now/table/incident/{{ current_incident_item.sys_id }}"
        method: PATCH
        user: "{{ servicenow_user }}"
        password: "{{ servicenow_password }}"
        force_basic_auth: yes
        body_format: json
        headers:
          Content-Type: "application/json"
        body:
          state: "9"
          assigned_to: ''
          comments: |
            Failed to process incident {{ current_incident_item.incident_number }} for host {{ current_incident_item.hostname }}.
            Possible reasons:
            - Host unreachable or SSH connection failed.
            - PowerShell command execution failed on the host.
            Please investigate manually.
            Error details: {{ ansible_failed_result | default('No specific error details available.') | to_json }}
      register: servicenow_error_update_result
      # Ensure this update attempt doesn't fail the playbook completely
      ignore_errors: true
      when: current_incident_item.sys_id is defined # Only attempt if sys_id is available
